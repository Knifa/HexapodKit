\documentclass{l4proj}

\usepackage{microtype}
\usepackage{hyperref}
\hypersetup{
    colorlinks = true,
    citecolor = black,
    linkcolor = black,
    urlcolor = black
}

\begin{document}
\pagenumbering{arabic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Visual Control of a Hexapod Robot}
\author{Daniel Callander}
\date{March 28, 2014}
\maketitle

\begin{abstract}
Some abstract.
\end{abstract}

\educationalconsent
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

\section{Objectives}
The primary objective of this project is to evaluate the usefulness of the Robot Operating System (ROS) \cite{ros_site} as a framework for developing complex robotic systems. Specifically, we explore the standard library of packages that ROS provides, in addition to the large set of community-provided packages. These packages provide a large of range of functionalities, ranging from device drivers for particular sets of sensors, to simulation suites, to full autonomous navigation suites.

As a secondary objective, we aim to evaluate the usefulness of open-source software as a means for accelerating development of these complex systems. Additionally, by using open-source software in this project, we set out to contribute in-kind by making any developments open-source.

\section{Achievements}
Through the use of ROS, we will show that it was possible to implement complex behaviours such environment mapping and autonomous navigation, achieved with relative simplicity. Almost all functionality for these behaviours were is by a these standard and community-provided packages. In particular, the robot is able to walk using standard walk gaits, detect an interpret the environment around it, and navigate around that environment while avoiding any obstacles.

Furthermore, we show that non-standard hardware, such as the robot used throughout this project, can be integrated with ROS with relative ease. Most examples of robots running ROS tend to move themselves using either wheels or tracks, but in this case a walker-style robot is used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Background and Related Works}

\section{ROS}

The \emph{Robot Operating System} (ROS) \cite{ros_site} is an open-source framework for creating robot control systems.

\subsection{Architecture}
ROS can be primarily thought of as a message-passing framework, similar to what is achieved by projects such as \emph{Erlang} \cite{erlang} and \emph{Akka}. A number of discrete processes, perhaps some even on a remote machine, communicate through a single broker service using an XMLRPC-based API. Each process performs a small part of a larger task, sharing data with other nodes through common data types, such that some robot control system can be implemented.

Each resource is given a name, and can be placed into a namespace. This gives each resource a unique \emph{graph resource name} which is the key method of referencing other parts of a system in ROS. As the name suggests, the layout of a ROS system can be thought of as a graph or tree. Some examples of \emph{graph resource names} are shown in Figure~\ref{fig:graph_resource_names}.

\begin{figure}[h!]
    \centering

    \texttt{/} (the global namespace)

    \texttt{/hexapod} (the \emph{hexapod} namespace)

    \texttt{/hexapod/servo\_controller} (a \emph{servo\_controller} node)

    \caption{An example of some graph resource names.}
    \label{fig:graph_resource_names}
\end{figure}

As touched on in the opening paragraph, ROS can function as a distributed system. Specifically, the processes can run on a machine different from that of the broker. The processes can then connect to the broker over some network. This can be used to offload complex computations onto another machine, should it be a requirement. To give an example, an embedded system running ROS on the robot can be collecting sensor data and issues hardware commands. This embedded system can then be communicating to a more powerful machine, acting as a base station. This base station can perform the more complex operations such as sensor data interpretation and path planning, relaying the commands back to the embedded system to be carried out.

\subsubsection{Processes as Nodes}
In ROS terminology, each of these processes are refereed to as a \emph{node}. A node is, simply, a process that is connected to the ROS broker, performing some sort computation.

Nodes are developed using a ROS \emph{client library}, many of which are available. These are libraries in some form for a particular language or ecosystem, providing an abstraction for interfacing with ROS. The two key client libraries are \emph{roscpp} and \emph{rospy}, which are for C++ and Python respectively. There are a number of experimental client libraries for other systems, such as Java, Android, C\#, Arduino, and so on.

\subsubsection{Grouping Nodes in Packages}
Nodes providing a particular set of functionalities (e.g., path planning for autonomous navigation), can be grouped and distributed as \emph{packages}.

There are a large number of open-source community-provided packages available from the ROS website.

\subsubsection{Communicating Through Topics}
Nodes communicate with each other through \emph{topics}.

\subsubsection{Services}
ROS also provides a \emph{request-respond} style method of communication through \emph{services}.

\subsubsection{Parameters}
\emph{Parameters} provide a standard means for configuring ROS nodes and packages.

\subsection{Standard Packages \& Utilities}
\subsubsection{Launching Packages with roslaunch}
\subsubsection{Visualising Sensor Data with RViz}


\section{Hardware}
\subsection{Hexapod}
The hardware involved in operating the robot used in this project is relatively straightforward. The robot is a hexapod, in that it has six limbs. Each limb has three joints at which it can rotate, as shown in Figure~\ref{fig:hexapod_dof}, giving three degrees-of-freedom per limb. 

\begin{figure}[!h]
    \centering
    (I am a diagram)
    \caption{This diagram shows the three degrees-of-freedom available to each limb on the robot.}
    \label{fig:hexapod_dof}
\end{figure}

At each joint there is a servo to facilitate rotation.

The servos are controlled by an off-the-shelf servo controller board. 

\subsection{RGB-D Sensor}
The primary sensor in the system is an \emph{ASUS Xtion Pro Live} RGB-D sensor, which is very similar to the \emph{Microsoft Kinect}. The key functionality of this sensor is that it provides a depth video feed, giving a range of values indicating the distances to the objects in front of it.

The advantages this particular sensor provides over the \emph{Kinect} is mostly physical, specifically weight and footprint. The \emph{Kinect} has a motorized base which allows the device to be tilted upwards and downwards through software, in comparison to the \emph{Xtion} which has a simple hinge that can be rotated by hand. This feature is unnecessary in this use case and adds a significant amount of weight. Additionally, the \emph{Kinect} is intended to be a consumer device and, thus, has a much striking product design. However, this striking design comes at a cost of making the device much larger in general, which is somewhat troubling when it must be placed on an already space-starved robot base.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Approach}


\section{Goals}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}

This chapter will document the implementation process of the robot's systems.

\section{Hardware Interaction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Servo Driver}
\subsubsection{Protocol}

\subsection{Limb Controller}

\subsection{Limb Calibration Tool}
\subsubsection{Usage}


\section{Locomotion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Tripod Gait Walker}
\subsection{Joystick Controller}

\section{Sensing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Camera Driver}
\subsection{Visual Odometry}
ccny\_rgbd \cite{ccny_rgbd}

\subsection{Environment Mapping}
\subsubsection{Alternatives}

\section{Navigation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Path Planning}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Usage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evaluation}

\section{Experimental Design}

\section{Results}
\subsection{Hardware Interaction}
\subsection{Locomotion}
\subsection{Sensing}
\subsection{Navigation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Further Work}


\section{Improved Hardware}
\section{Untethered Operation}
\section{Inverse IK}
\section{Additional Sensors}
\section{Facial Recognition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}


\section{Summary}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{report}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
